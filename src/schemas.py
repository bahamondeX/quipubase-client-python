import json
from typing import Any, Optional, TypeVar
from uuid import UUID, uuid4

from pydantic import BaseModel, Field

from .utils import encrypt, get_logger

T = TypeVar("T", bound="Collection")

logger = get_logger("[Collections]")


class Collection(BaseModel):
	"""
	Represents a collection model with utility methods for schema manipulation
	and tool definition.

	Attributes:
		id (Optional[UUID]): A unique identifier for the collection, 
			generated by default using `uuid4`.

	Methods:
		__repr__():
			Returns a JSON-formatted string representation of the model.

		__str__():
			Returns the same JSON-formatted string representation as `__repr__`.

		col_id():
			Class method that returns an encrypted JSON string of the model's
			JSON schema.

		tool_definition() -> dict[str, Any]:
			Class method that returns a dictionary defining the tool's metadata,
			including its type, name, description, and parameters.

		tool_param():
			Class method that returns a dictionary containing the input schema,
			name, description, and cache control settings for the tool.
	"""
	id: Optional[UUID] = Field(default_factory=uuid4)

	def __repr__(self):
		return self.model_dump_json(indent=4)

	def __str__(self):
		return self.__repr__()

	@classmethod
	def col_id(cls):
		return encrypt(json.dumps(cls.model_json_schema()))

	@classmethod
	def tool_definition(cls) -> dict[str, Any]:
		return {
			"type": "function",
			"function": {
				"name": cls.__name__,
				"description": cls.__doc__ or "",
				"parameters": cls.model_json_schema().get("properties", {}),
			},
		}

	@classmethod
	def tool_param(cls):
		return dict(
			input_schema=cls.model_json_schema(),
			name=cls.__name__,
			description=cls.__doc__ or "",
			cache_control={"type": "ephemeral"},
		)
